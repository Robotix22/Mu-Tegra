// Copyright (c) 2019 - 2020, Bingxing Wang and other project authors. All rights reserved.<BR>
// Copyright (c) 2021 - 2021, Leander Wollersberger. All rights reserved.<BR>

#include "UEFILoader.h"

#include <Library/ArmLib.h>
#include <Library/ArmSmcLib.h>

UINT32
ArmCallSmcHelper(
  UINT32 R0,
  UINT32 R1,
  UINT32 R2,
  UINT32 R3)
{
  ARM_SMC_ARGS ArmSmcArgs;

  DEBUG ((EFI_D_WARN, "[DEBUG] %a: >>> {0x%08x, 0x%08x, 0x%08x, 0x%08x}\n", __FUNCTION__, R0, R1, R2, R3));

  ArmSmcArgs.Arg0 = R0;
  ArmSmcArgs.Arg1 = R1;
  ArmSmcArgs.Arg2 = R2;
  ArmSmcArgs.Arg3 = R3;

  ArmCallSmc(&ArmSmcArgs);

  DEBUG ((EFI_D_WARN, "[DEBUG] %a: <<< {0x%08x, 0x%08x, 0x%08x, 0x%08x}\n", __FUNCTION__, ArmSmcArgs.Arg0, ArmSmcArgs.Arg1, ArmSmcArgs.Arg2, ArmSmcArgs.Arg3));

  return ArmSmcArgs.Arg0;
}

EFI_STATUS
UnprotectTZ()
{
  UINT32 Value = 0;

  // Get Size of the Buffers needed
  Value = ArmCallSmcHelper(0x3, 0x9, 0, 0);
  DEBUG ((EFI_D_WARN, "[DEBUG] %a: 0x%x\n", __FUNCTION__, Value));

  // Switch Secure Word Handlers to Runtime Mode
  Value = ArmCallSmcHelper(0x3, 0x5, 0, 0);
  DEBUG ((EFI_D_WARN, "[DEBUG] %a: 0x%x\n", __FUNCTION__, Value));

  // Register a new Shared Memory Buffer at 0x40000000 (IRAM) with Size 0x6001E0E0 or 0x600320E0
  // The Following Algorithm is used to determine the End Address that the Query Variable call will write over:
  // response_area = (request_area + (area_slice >> 1));
  Value = ArmCallSmcHelper(0x3, 0x6, 0x40000000, 0x6001E0E0);

  DEBUG ((EFI_D_WARN, "[DEBUG] %a: 0x%x\n", __FUNCTION__, Value));

  // Query Variable, does a 32 Byte Memory Copy over to 0x7000f070...f090
  // (MC_SECURITY_CFG0, MC_SECURITY_CFG1 and reserved registers)
  gBS->SetMem((VOID *)0x40000000, 32, 0);
  Value = ArmCallSmcHelper(0x3, 0x3, 0, 0);
  DEBUG ((EFI_D_WARN, "[DEBUG] %a: 0x%x\n", __FUNCTION__, Value));

  // Check if TZ has been Unprotected
  ArmDisableCachesAndMmu();

  UINT32 Check = *((UINT32 *)(EFI_PHYSICAL_ADDRESS)0x80000000);

  ArmEnableMmu();
  ArmEnableDataCache();
  ArmEnableInstructionCache();

  if (Check == 0xFFFFFFFF) {
    return EFI_SECURITY_VIOLATION;
  }

  return EFI_SUCCESS;
}